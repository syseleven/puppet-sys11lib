#!/usr/bin/env bash

##
## WARNING: This file is auto-generated by puppet!
## WARNING: To change it, edit the file in <%= file[/.*\/(.*?\/templates\/.*)/, 1] %>
##


##
## config
##
c_lockdir='/tmp/check_ssl_certificates'
c_logfile='/var/log/check_ssl_certificates.log'
c_cache='/var/cache/ssl'
c_result='/var/cache/ssl/last.result'
c_grades='ABCDEFMT'
c_api_url='https://api.ssllabs.com/api/v2'

##
## nrpe return codes
##
nrpe_ok=0
nrpe_wa=1
nrpe_cr=2
nrpe_un=3

##
## result counter
##
i_result_ok=0
i_result_wa=0
i_result_cr=0
i_result_sk=0

##
## parameters, flags and defaults
##
p_autodetect=true
p_blacklist=''
p_blacklist_file=''
p_whitelist=''
p_whitelist_file=''
p_cert_blacklist=''
p_cert_blacklist_file=''
p_service=''
p_ok_when='A'
p_warning_when='BC'
p_critical_when='DEFMT'
p_curl_recheck_runs=5
p_recheck_status_interval=10
p_recheck_status_timeout=300
p_result_cache_time=604800
p_clear_cache=false
p_check_ip=true
p_verbose='false'

##
## some more variables
##
autodetect_service=''
autodetect_certificates=''
autodetect_domains=''
r_code=-1

##
## json helpers
##
json_get_status='import json,sys;sys.stdout.write(json.dumps(json.load(sys.stdin)["status"]))'
json_get_grade='import json,sys;sys.stdout.write(json.dumps(json.load(sys.stdin)["endpoints"][0]["grade"]))'
json_get_message='import json,sys;sys.stdout.write(json.dumps(json.load(sys.stdin)["endpoints"][0]["statusMessage"]))'
json_cnt_endpoints='import json,sys;sys.stdout.write(str(len(json.load(sys.stdin)["endpoints"])))'
json_get_domain='import json,sys;sys.stdout.write(json.dumps(json.load(sys.stdin)["endpoints"][0]["serverName"]))'
json_get_ipaddress='import json,sys;sys.stdout.write(json.dumps(json.load(sys.stdin)["endpoints"][0]["ipAddress"]))'

##
## display_usage()
##
## print a usage to stdout
##
display_usage() {
  printf "%s\n" "$(basename ${0})"
  printf " -a | --autodetect                   enable autodetection of certificates\n"
  printf " -A | --disable-autodetect           disable autodetection of certificates\n"
  printf " -b | --blacklist                    add a domain to the blacklist (don't check this domain)\n"
  printf " -B | --blacklist-file               get blacklisted domains from this file\n"
  printf " -w | --whitelist                    add a domain to the whitelist (check this domain)\n"
  printf " -W | --whitelist-file               get whitelisted domains from this file\n"
  printf " -c | --blacklist-certificate        add a certificate to the blacklist (don't check this certificate)\n"
  printf " -C | --blacklist-certificate-file   get blacklisted certificates from this file\n"
  printf " -s | --service                      specify service to prevent autodetection\n"
  printf " --ok-when                           define when script return ok for a domain (default: A)\n"
  printf " --warning-when                      define when script return warning for a domain (default: BC)\n"
  printf " --critical-when                     define when script return critical for a domain (default: DEFT)\n"
  printf " --curl-recheck-runs                 recheck in case of known curl error this times\n"
  printf " --recheck-status-interval           recheck the status in this interval\n"
  printf " --recheck-status-timeout            timeout for status recheck\n"
  printf " --result-cache-time                 cache results for domains for this time\n"
  printf " --clear-cache                       clear cache for all domains\n"
  printf " --skip-ip-check                     skip the check if the IP is bound to this server\n"
  printf " -v | --verbose                      display output\n"
  printf " -q | --quiet                        hide output\n"
  printf " -h | --help                         display this usage\n\n"

  exit ${1:-0}
}

##
## log()
##
## $1: the message
##
## write the given message to the logfile and write it also to stdout if the script was started in a shell
##
log() {
  prefix="$(date +%F' '%T) [${$}]  "
  if tty -s; then
    printf "%s\n" "${1:-empty message}" | sed "s#^#${prefix}#g;" | tee -a ${c_logfile:-/var/log/check_ssl_certificates.log}
  else
    printf "%s\n" "${1:-empty message}" | sed "s#^#${prefix}#g;" > ${c_logfile:-/var/log/check_ssl_certificates.log}
  fi
}

##
## return_to_nagios()
##
## $1: the nagios return code
## $2: the nagios return text
##
## log the return state of the check and update the resultfile
##
return_to_nagios() {
  case ${1} in
    ${nrpe_ok}) message="OK: ${2:-empty parameter}";;
    ${nrpe_wa}) message="WARNING: ${2:-empty parameter}";;
    ${nrpe_cr}) message="CRITICAL: ${2:-empty parameter}";;
    *)          message="UNKNOWN: ${2:-empty parameter}";;
  esac

  log "$(printf "%s\n" "${message}" | sed 's#^#nrpe return: #g;')"

  printf "TIMESTAMP:%s\nRETURNCODE:%s\n%b\n" "$(date +%s)" "${1:-$nrpe_un}" "${2:-unspecified message}" > ${c_result}
  exit ${1}
}

##
## locking()
##
## cause nobody likes cronjobs running twice a time
## 
lock_script() {
  if mkdir "${c_lockdir}"; then
    trap 'rm -rf "${c_lockdir}"' 0
    trap "exit 2" 1 2 3 15
  else
    return_to_nagios "${nrpe_wa}" "cannot acquire lock, giving up on ${c_lockdir}"
  fi

  log 'script is locked'
}

##
## parse_commandline()
##
## parsing the commandline parameters and update all flags and values
##
parse_commandline() {
  cmdline_parameters="${*}"

  # get parameters from commandline
  parameters=$(getopt -o 'aAb:B:w:W:c:C:s:vqh' --long 'autodetect,disable-autodetect,blacklist:,blacklist-file:,whitelist:,whitelist-file:,blacklist-certificate:,blacklist-certificate-file:,service:,ok-when:,warning-when:,critical-when:,curl-recheck-runs:,recheck-status-interval:,recheck-status-timeout:,result-cache-time:,clear-cache,skip-ip-check,verbose,quiet,help' -- "${@}" 2>/dev/null)
  if [ ${?} -ne 0 ]; then
    display_usage 1
  fi

  # parse parameters
  eval set -- "${parameters}"
  while true; do
    case "${1}" in
      -a | --autodetect)                   p_autodetect=true; shift;;
      -A | --disable-autodetect)           p_autodetect=false; shift;;
      -b | --blacklist)                    p_blacklist="${p_blacklist} ${2}"; shift 2;;
      -B | --blacklist-file)               p_blacklist_file=${2}; shift 2;;
      -w | --whitelist)                    p_whitelist="${p_whitelist} ${2}"; shift 2;;
      -W | --whitelist-file)               p_whitelist_file=${2}; shift 2;;
      -c | --blacklist-certificate)        p_cert_blacklist="${p_blacklist} ${2}"; shift 2;;
      -C | --blacklist-certificate-file)   p_cert_blacklist_file=${2}; shift 2;;
      -s | --service)                      p_service=${2}; shift 2;;
      --ok-when)                           p_ok_when=${2}; shift 2;;
      --warning-when)                      p_warning_when=${2}; shift 2;;
      --critical-when)                     p_critical_when=${2}; shift 2;;
      --curl-recheck-runs)                 p_curl_recheck_runs=${2}; shift 2;;
      --recheck-status-interval)           p_recheck_status_interval=${2}; shift 2;;
      --recheck-status-timeout)            p_recheck_status_timeout=${2}; shift 2;;
      --result-cache-time)                 p_result_cache_time=${2}; shift 2;;
      --clear-cache)                       p_clear_cache=true; shift;;
      --skip-ip-check)                     p_check_ip=false; shift;;
      -v | --verbose)                      verbose=true; shift;;
      -q | --quiet)                        verbose=false; shift;;
      -h | --help)                         display_usage; shift;;
      -- )                                 shift; break;;
      * )                                  break;;
    esac
  done
  log "*** separator *****************************************************************"
  log "parameters: ${cmdline_parameters}"
}

##
## check_parameters()
##
## some checks to prevent from unexpected behavior
##
check_parameters() {
  # check parameter for nagios limits
  for grade in $(printf "%s\n" "${c_grades}" | sed 's/\(.\)/\1 /g;'); do
    grade_count=$(printf "%s%s%s\n" "${p_ok_when}" "${p_warning_when}" "${p_critical_when}" | grep -o ${grade} | wc -l)
    if [ ${grade_count} -ne 1 ]; then
      return_to_nagios "${nrpe_wa}" "grade ${grade} is defined ${grade_count} times"
    fi
  done

  # ensure that recheck-status-timeout is bigger than recheck-status-interval
  if [ ${p_recheck_status_timeout} -le ${p_recheck_status_interval} ]; then
    return_to_nagios "${nrpe_wa}" "recheck-status-timeout should be bigger than recheck-status-interval"
  fi
}

##
## build_domain_list()
##
## goal is to have a list of all domains to check in ${autodetect_domains}
##
build_domain_list() {
  if ${p_autodetect}; then
    log "autodetection: initiated"
    autodetect_domains
  else
    log "autodetection: disabled"
  fi
  handle_blacklist
  handle_whitelist

  # return if no domains was found
  if [ -z "${autodetect_domains}" ]; then
    return_to_nagios "${nrpe_ok}" "no domain to check found or defined"
  fi
}

##
## detect_service()
##
## goal is to have a the service which opens port 443 in ${autodetect_service}
##
detect_service() {
  # is service specified?
  if [ "${p_service}" != "" ]; then
    autodetect_service="${p_service}"
    log "service specified as: ${autodetect_service}"
    return
  fi

  # is port 443 open?
  if ! netstat -lnt | grep 443 | sed 's#:443.*##g;s#.*[ \t]##g;s#^\(127\|10\)\..*##g;' | grep -c "." > /dev/null; then
    return_to_nagios "${nrpe_ok}" 'port 443 is not open'
  fi
  log 'open port detected: 443'

  # which daemon is running on port 443
  pid=$(netstat -tlpn | grep 443 | sed 's#[ \t]\+# #g;s#.*LISTEN ##g;s#/.*##g;' | sort | uniq)
  autodetect_service=$(ps ho command ${pid} | grep -o "nginx\|apache" | sort | uniq)
  log "autodetected service: ${autodetect_service}"
}

##
## get_certificates()
##
## another goal, this time we want to have a list of certificates to check in ${autodetect_certificates}
##
get_certificates() {
  case ${autodetect_service} in
    nginx)  config_files="/etc/nginx/nginx.conf $(grep 'include' /etc/nginx/nginx.conf | sed 's#\#.*##g;s#.*include[ \t]\+##g;s#;.*##g;s#[ \t]\+$##g;s#^/etc/nginx/##g;s#^#/etc/nginx/#g;s#^/etc/nginx/$##g;' | tr '\n' ' ')"
            autodetect_certificates="$(cat ${config_files} \
              | grep -w 'ssl_certificate' \
              | sed 's#[ \t]\+# #g;s#\# ssl_certificate##g;s#;.*$##g;' \
              | grep -v '#ssl_certificate' \
              | awk '{ print $NF; }' | sort | uniq)";;
    apache) autodetect_certificates="$(grep -rwi 'SSLCertificateFile' /etc/apache2/ \
              | sed 's#[ \t]\+# #g;s#\#.*##g;s#.*: ##g;' \
              | awk '{ print $NF; }' \
              | grep "." | sort | uniq)";;
    *)      return
            ;;
  esac
}

##
## get_domains()
##
## get all configured domains form detected service
##
get_domains() {
  # return if no cert was found
  if [ -z "${autodetect_certificates}" ]; then
    return
  fi

  # get domains from certificates
  for certificate in ${autodetect_certificates}; do
    log "autodetect certificate: ${certificate}"

    # is certificate existing?
    if [ ! -f "${certificate}" ]; then
      log "autodetect domain: certificate does not exist"
      continue
    fi

    # get domains from certificate matching www,* or matching \*.* (wildcards) and then the others
    domains="$(openssl x509 -text -noout -in ${certificate} | grep DNS | sed 's#[ \t]\+DNS:##g;s#,# #g;s#^\*\.#www.#g;' | tr ' ' '\n' | grep '^www\|^\*.' | sort -t'.' -k2)"
    domains="${domains} $(openssl x509 -text -noout -in ${certificate} | grep DNS | sed 's#[ \t]\+DNS:##g;s#,# #g;' | tr ' ' '\n' | grep -v '^www\|^\*.' | sort)"
    domains="$(printf "%s\n" "${domains}" | sed 's#^[ \t]\+##g;s#[ \t]\+$##g;s#[ \t]\+# #g;')"

    # store one domain per certificate
    if [ -z "${domains}" ]; then
      log "skipping selfsigned certificate ${certificate}"
    else
      # extract one domain for the check
      found=false; for domain in ${domains}; do
        # get IP for this domain
        domain_ip="$(ping -c1 -W2 "${domain}" 2>/dev/null | grep '^PING' | sed 's#.* (##g;s#).*##g;')"

        # IP is empty -> continue
        if [ -z "${domain_ip}" ]; then
          log "cannot get IP for ${domain}, skipping check for this domain"
          continue
        fi

        # ip is not a SysEleven-IP
        if ${p_check_ip}; then
          if [ "${domain_ip:0:3}" != '10.' -a "${domain_ip:0:4}" != '127.' ]; then
            if [ $(whois "${domain_ip}" | grep -cwi syseleven) -eq 0 ]; then
              log "the IP ${domain_ip} ${domain} resolves to is not a SysEleven IP, skipping check for this domain"
              continue
            fi
          fi
        fi

        # ip isn't empty and a SysEleven-IP: BINGO!
        autodetect_domains="${autodetect_domains} ${domain}"
        log "adding autodetected domain: ${domain}"
        found=true
        break
      done

      # in case no domain has an ip an is a SysEleven-IP
      if ! ${found}; then
        log "no domain fulfills the requirements, skipping certificate ${certificate}"
        i_result_sk="$(printf "%s+1\n" "${i_result_sk}" | bc)"
      fi
    fi
  done

  # uniq the domains
  autodetect_domains="$(printf "%s\n" "${autodetect_domains}" | tr ' ' '\n' | sort | uniq | tr '\n' ' ')"
}

##
## autodetect_domains()
##
## autodetection for domains
##
autodetect_domains() {
  detect_service
  get_certificates
  handle_certificate_blacklist
  get_domains

  # return if no domains was found
  if [ -z "${autodetect_domains}" ]; then
    return
  fi
}

##
## handle_certificate_blacklist()
##
## handle all blacklisted certificates
##
handle_certificate_blacklist() {
  # handle blacklisted domains from parameter
  for blacklisted_certificate in ${p_cert_blacklist}; do
    log "blacklisting certificate: ${blacklisted_certificate}"
    autodetect_certificates="$(printf "%s\n" "${autodetect_certificates}" | sed "s#${blacklisted_certificate}##g;s#^ ##g;s#  # #g;")"
  done

  # handle blacklisted domains from file
  if [ -f "${p_cert_blacklist_file}" ]; then
    for blacklisted_certificate in $(cat ${p_cert_blacklist_file}); do
      log "blacklisting certificate: ${blacklisted_certificate}"
      autodetect_certificates="$(printf "%s\n" "${autodetect_certificates}" | sed "s#${blacklisted_certificate}##g;s#^ ##g;s#  # #g;")"
    done
  fi
}

##
## handle_blacklist()
##
## handle all blacklisted domains
##
handle_blacklist() {
  # handle blacklisted domains from parameter
  for blacklisted in ${p_blacklist}; do
    log "blacklisting domain: ${blacklisted}"
    autodetect_domains="$(printf "%s\n" "${autodetect_domains}" | sed "s#${blacklisted}##g;s#^ ##g;s#  # #g;")"
  done

  # handle blacklisted domains from file
  if [ -f "${p_blacklist_file}" ]; then
    for blacklisted in $(cat ${p_blacklist_file}); do
      log "blacklisting domain: ${blacklisted}"
      autodetect_domains="$(printf "%s\n" "${autodetect_domains}" | sed "s#${blacklisted}##g;s#^ ##g;s#  # #g;")"
    done
  fi
}

##
## handle_whitelist()
##
## handle all blacklisted domains
##
handle_whitelist() {
  # handle whitelisted domains from parameter
  for whitelisted in ${p_whitelist}; do
    log "whitelisting domain: ${whitelisted}"
    autodetect_domains="${autodetect_domains} ${whitelisted}"
  done

  # handle whitelisted domains from file
  if [ -f "${p_whitelist_file}" ]; then
    for whitelisted in $(cat ${p_whitelist_file}); do
      log "whitelisting domain: ${whitelisted}"
      autodetect_domains="${autodetect_domains} ${whitelisted}"
    done
  fi
}

##
## execute_curl()
##
## $1: url
## $2: outpotfile (default /dev/null)
##
## execute a curl and handle some known errors
##
execute_curl() {
  for i in $(seq 1 1 ${p_curl_recheck_runs}); do
    log "curl: ${1}"
    r=$(curl -s --write-out "%{http_code}\n" ${1} -o ${2:-/dev/null})
    case ${r} in
      400) return_to_nagios "${nrpe_cr}" "invalid check parameters, please check manually"
           break
           ;;
      429) log "curl error: client request rate too high"
           break
           ;;
      500) sleep 60;  log "curl error: internal error";;
      503) sleep 300; log "curl error: the service is not available (e.g., down for maintenance)";;
      529) sleep 60;  log "curl error: the service is overloaded";;
      *)   break;;
    esac

    # restore cache in case of an error
    if [ ${r} -ge 400 ]; then
      restore_cache "$(printf "%s\n" "${r}" | sed 's#400#invalid check parameters, please check manually#g;s#429#client request rate too high#g;s#500#internal error#g;s#503#the service is not available (e.g., down for maintenance)#g;s#529#the service is overloaded#g;')"
    fi
  done
}

##
## initialize_certificate_check()
##
## $1: domain
##
## initiate the check via ssllabs api
##
initialize_certificate_check() {
  execute_curl "${c_api_url}/analyze?host=${1}&publish=Off&clearCache=On&all=on&startNew=On"
}

##
## get_certificate_check_status()
##
## $1: domain
##
## try to get the result via ssllabs api
##
get_certificate_check_status() {
  # set timeout limit
  timeout_limit=$(date +%s)
  timeout_limit=$(printf "%s+%s\n" "${timeout_limit}" "${p_recheck_status_timeout}" | bc)

  sleep ${p_recheck_status_interval}
  # is check finished?
  while [ $(curl -s "${c_api_url}/analyze?host=${1}&publish=Off&clearCache=Off&all=On" | python -c "${json_get_status}" | grep "IN_PROGRESS") ]; do
    sleep ${p_recheck_status_interval}
    # timed out?
    if [ $(date +%s) -gt ${timeout_limit} ]; then
      return_to_nagios "${nrpe_wa}" "curl recheck timeout: ${1}"
    fi
  done

  # get result
  execute_curl "${c_api_url}/analyze?host=${1}&publish=Off&clearCache=Off&all=On" "${c_cache}/${1}.response"
}

##
## get_result_from_response()
##
## $1: domain
##
## parse the result to extract the grade
##
get_result_from_response() {
  r_state=$(python -c "${json_get_status}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
  r_grade=$(python -c "${json_get_grade}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
  r_stmsg=$(python -c "${json_get_message}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
  r_count=$(python -c "${json_cnt_endpoints}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')

  # get endpoint
  if [ "${r_count}" != '1' ]; then
    log "there are ${r_count} endpoints"
    for i in $(seq 1 1 ${r_count}); do
      # get number of previous item
      pi=$(printf '%s-1\n' "${i}" | bc)

      # build json helpers
      p_grade="$(printf '%s\n' "${json_get_grade}" | sed "s#\[0\]#\[${pi}\]#g;")"
      p_stmsg="$(printf '%s\n' "${json_get_message}" | sed "s#\[0\]#\[${pi}\]#g;")"
      p_domain="$(printf '%s\n' "${json_get_domain}" | sed "s#\[0\]#\[${pi}\]#g;")"
      p_ip="$(printf '%s\n' "${json_get_ipaddress}" | sed "s#\[0\]#\[${pi}\]#g;")"

      # get grade, message, domain and ip for current endpoint
      r_grade=$(python -c "${p_grade}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
      r_stmsg=$(python -c "${p_stmsg}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
      r_domain=$(python -c "${p_domain}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')
      r_ip=$(python -c "${p_ip}" < ${c_cache}/${1}.response 2>/dev/null | sed 's#"##g;')

      # get ip domain resolves to
      domain_ip="$(ping -c1 -W2 "${1}" 2>/dev/null | grep '^PING' | sed 's#.* (##g;s#).*##g;')"

      # print data for endpoint
      log "endpoint ${i}: ${r_domain} (${r_ip})"

      # break if domain or ip is matching
      if [ "${1}" == "${r_domain}" ]; then
        log "grade for endpoint ${i}: ${r_grade}"
        log "breaking loop through endpoints cause domain is matching"
        break
      elif [ "${domain_ip}" == "${r_ip}" ]; then
        log "grade for endpoint ${i}: ${r_grade}"
        log "breaking loop through endpoints cause ip is matching"
        break
      else
        log "cannot get grade for endpoint ${i}, message: ${r_stmsg}"
      fi
    done
  fi

  # handle result
  if [ "${r_state}" = "READY" ]; then
    # update returncode
    case ${r_grade} in
      [${p_ok_when}]*)        if [ ${r_code} -le ${nrpe_ok} ]; then r_code=${nrpe_ok}; fi; i_result_ok="$(printf "%s+1\n" "${i_result_ok}" | bc)";;
      [${p_warning_when}]*)   if [ ${r_code} -le ${nrpe_wa} ]; then r_code=${nrpe_wa}; fi; i_result_wa="$(printf "%s+1\n" "${i_result_wa}" | bc)";;
      [${p_critical_when}]*)  if [ ${r_code} -le ${nrpe_cr} ]; then r_code=${nrpe_cr}; fi; i_result_cr="$(printf "%s+1\n" "${i_result_cr}" | bc)";;
      *)                      r_code=${nrpe_un};;
    esac

    # update response
    if [ -n "${r_grade}" ]; then
      log "grade for domain ${1}: ${r_grade}"
      printf "grade for domain %s: %s%s\n" "${1}" "${r_grade}" "${2:-}" >> ${c_lockdir}/current.result
    else
      log "cannot get grade for domain ${1}, message: ${r_stmsg}"
      printf "cannot get grade for domain %s, message: %s\n" "${1}" "${r_stmsg}" >> ${c_lockdir}/current.result
    fi
    cat ${c_cache}/${1}.response > ${c_cache}/${1}.last.success
  else
    # update response
    log "cannot get grade for domain ${1}, message: ${r_stmsg}"
    printf "cannot get grade for domain %s, message: %s\n" "${1}" "${r_stmsg}" >> ${c_lockdir}/current.result
    cat ${c_cache}/${1}.response > ${c_cache}/${1}.last.failure

    # remove cached file to force a recheck
    rm ${c_cache}/${1}.response
  fi
}

##
## check_cache()
##
## check if all cached files are valid
##
check_cache() {
  if ${p_clear_cache}; then
    for d in ${autodetect_domains}; do
      log "clearing cached result: ${d}"
      mv ${c_cache}/${d}.response ${c_cache}/${d}.response.cached
    done
  else
    while read c; do
      cache_limit="$(printf "%s+%s\n" "$(ls -l --time-style=+%s ${c} | awk '{print $6;}')" "${p_result_cache_time}" | bc)"
      if [ $(date +%s) -gt ${cache_limit} ]; then
        log "clearing cached result: ${c}"
        mv ${c} ${c}.cached
      fi
    done < <(find ${c_cache} -type f -name "*.response")
  fi
}

##
## restore_cache()
##
## $1: the warning message
##
## in case the api is not available or we send to many requests we
## restore the cache and return a warning
##
restore_cache() {
  log "restoring cache in cause of \"${1:-empty_parameter}\""
  while read c; do
    # continue if valid result was available
    if [ -f ${c} -a "$(python -c "${json_get_status}" < ${c_cache}/${1}.response | sed 's#"##g;')" = "READY" ]; then
      log "not restoring cache for ${c##./} cause state was \"READY\""
      continue
    fi

    # restore the cache
    log "restoring cached result for ${c//\.response}"
    mv ${c}.cached ${c}
  done < <(find ${c_cache} -type f -name "*.response.cached")
}

##
## check_certificates()
##
## check all domains, detected and listed ones in a loop
##
check_certificates() {
  # return to nagios if no valid domain was detected
  if [ -z "$(printf "%s\n" "${autodetect_domains}" | sed 's#[ \t]*##g;')" ]; then
    return_to_nagios "${nrpe_ok}" "no domain fulfills the requirements, so here is nothing to do for me"
  fi

  # check the domains
  for domain in ${autodetect_domains}; do
    if [ -f ${c_cache}/${domain}.response ]; then
      log "getting result from cache for domain: ${domain}"
      get_result_from_response "${domain}" " (cached)"
    else
      log "check domain: ${domain}"
      initialize_certificate_check "${domain}"
      get_certificate_check_status "${domain}"
      get_result_from_response "${domain}"
    fi
  done
}

##
## parse_results()
##
## build a nice looking responsetext
##
parse_results() {
  if [ ${i_result_ok} -eq 1 ]; then result_string="${i_result_ok} certificate OK, "; else result_string="${i_result_ok} certificates OK, "; fi
  if [ ${i_result_wa} -eq 1 ]; then result_string="${result_string}${i_result_wa} certificate WARNING, "; else result_string="${result_string}${i_result_wa} certificates WARNING, "; fi
  if [ ${i_result_cr} -eq 1 ]; then result_string="${result_string}${i_result_cr} certificate CRITICAL "; else result_string="${result_string}${i_result_cr} certificates CRITICAL "; fi
  if [ ${i_result_sk} -eq 1 ]; then result_string="${result_string}and ${i_result_sk} certificate skipped"; else result_string="${result_string}and ${i_result_sk} certificates skipped"; fi

  sed -i "1 s#^#${result_string}\n#;" ${c_lockdir}/current.result
  return_to_nagios "${r_code}" "$(cat ${c_lockdir}/current.result)"
}

##
## start of the main procedure
##
if [ ! -d ${c_cache:-/var/cache/ssl} ]; then
  mkdir -p ${c_cache:-/var/cache/ssl}
fi
parse_commandline ${*}
lock_script
check_parameters
build_domain_list
check_cache
check_certificates
parse_results

